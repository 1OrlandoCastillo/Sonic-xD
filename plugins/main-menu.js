import { xpRange } from '../lib/levelling.js';

const clockString = ms => {
  const h = Math.floor(ms / 3600000);
  const m = Math.floor(ms / 60000) % 60;
  const s = Math.floor(ms / 1000) % 60;
  return [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');
};

let img = 'https://files.catbox.moe/6dewf4.jpg';

function saludarSegunHora() {
  const hora = new Date().getHours();
  if (hora>= 5 && hora < 12) return 'üåÑ Buenos d√≠as';
  if (hora>= 12 && hora < 19) return 'üåû Buenas tardes';
  return 'üåô Buenas noches';
}

let menuText = `
‚ï≠‚îÄ‚ùí „Äå s·•≤s·•ôk·•± ·ë≤·•Üùóç m·É´ üåÄ „Äç
‚îÇ üë§ *Nombre:* %name
‚îÇ üéñ *Nivel:* %level | *XP:* %exp/%max
‚îÇ üîì *L√≠mite:* %limit | *Modo:* %mode
‚îÇ ‚è±Ô∏è *Uptime:* %uptime
‚îÇ üåç *Usuarios:* %total
‚îÇ ü§ñ *Bot optimizado para mejor rendimiento.*
‚ï∞‚ùí
`.trim();

const sectionDivider = '‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ';

const menuFooter = `
‚ï≠‚îÄ‚ùí „Äå *üìå INFO FINAL* „Äç
‚îÇ ‚ö†Ô∏è *Usa los comandos con el prefijo correspondiente.*

> Creado por Barboza-Team
‚ï∞‚ùí
`.trim();

let handler = async (m, { conn, usedPrefix: _p }) => {
  const fkontak = {
    key: {
      participants: "0@s.whatsapp.net",
      remoteJid: "status@broadcast",
      fromMe: false,
      id: "Halo"
    },
    message: {
      contactMessage: {
        vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Sy;Bot;;;\nFN:y\nitem1.TEL;waid=${m.sender.split('@')[0]}:${m.sender.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD`
      }
    },
    participant: "0@s.whatsapp.net"
  };

  try {
    if (!global.db || !global.db.data || !global.db.data.users) {
      console.error("Error: global.db.data.users no est√° inicializado o no es accesible.");
      return conn.reply(m.chat, '‚ö†Ô∏è El bot no tiene acceso a la base de datos de usuarios. Por favor, reporta esto al desarrollador.', m);
    }

    const user = global.db.data.users[m.sender] || { level: 1, exp: 0, limit: 5 };
    const { exp, level, limit } = user;

    const { min, xp } = xpRange(level, global.multiplier || 1);

    const totalreg = Object.keys(global.db.data.users).length;

    const mode = global.opts?.self ? 'Privado üîí' : 'P√∫blico üåê';

    const uptime = clockString(process.uptime() * 1000);

    let userName = "Usuario";
    try {
      userName = await conn.getName(m.sender);
    } catch (e) {
      console.error("Error al obtener el nombre del usuario:", e);
    }

    let categorizedCommands = {};

    if (!global.plugins) {
      console.error("Error: global.plugins no est√° inicializado. No se pueden cargar los comandos.");
      return conn.reply(m.chat, '‚ö†Ô∏è Los comandos del bot no est√°n cargados. Por favor, reporta esto al desarrollador.', m);
    }

    Object.values(global.plugins)
      .filter(p => p?.help && !p.disabled)
      .forEach(p => {
        const tags = Array.isArray(p.tags) ? p.tags : (typeof p.tags === 'string' ? [p.tags] : ['Otros']);
        const tag = tags[0] || 'Otros';

        const commands = Array.isArray(p.help) ? p.help : (typeof p.help === 'string' ? [p.help] : []);

        if (commands.length > 0) {
          categorizedCommands[tag] = categorizedCommands[tag] || new Set();
          commands.forEach(cmd => categorizedCommands[tag].add((_p === '' ? '' : _p) + cmd));
        }
      });

    const categoryEmojis = {
      anime: "üé≠",
      info: "‚ÑπÔ∏è",
      search: "üîé",
      diversi√≥n: "üéâ",
      subbots: "ü§ñ",
      rpg: "üåÄ",
      registro: "üìù",
      sticker: "üé®",
      imagen: "üñºÔ∏è",
      logo: "üñåÔ∏è",
      premium: "üéñÔ∏è",
      configuraci√≥n: "‚öôÔ∏è",
      descargas: "üì•",
      herramientas: "üõ†Ô∏è",
      nsfw: "üîû",
      "base de datos": "üìÄ",
      audios: "üîä",
      "free fire": "üî•",
      otros: "ü™™"
    };

    const menuBody = Object.entries(categorizedCommands).map(([title, cmds]) => {
      const cleanTitle = title.toLowerCase().trim();
      const emoji = categoryEmojis[cleanTitle] || "üìÅ";
      const commandEntries = [...cmds].map(cmd => `‚îÇ ‚ó¶ _${cmd}_`).join('\n');
      return `‚ï≠‚îÄ„Äå ${emoji} *${title.toUpperCase()}* „Äç\n${commandEntries}\n${sectionDivider}`;
    }).join('\n\n');

    const finalHeader = menuText
      .replace('%name', userName)
      .replace('%level', level)
      .replace('%exp', exp - min)
      .replace('%max', xp)
      .replace('%limit', limit)
      .replace('%mode', mode)
      .replace('%uptime', uptime)
      .replace('%total', totalreg);

    const fullMenu = `${finalHeader}\n\n${menuBody}\n\n${menuFooter}`;

    try {
      await conn.sendMessage(m.chat, {
        image: { url: img },
        caption: fullMenu,
        mentions: [m.sender]
      }, { quoted: m });
    } catch (sendError) {
      console.error("Error al enviar la imagen del men√∫, enviando como texto:", sendError);
      await conn.reply(m.chat, fullMenu, m);
    }

  } catch (e) {
    console.error("Error general al generar el men√∫:", e);
    conn.reply(m.chat, '‚ö†Ô∏è Ocurri√≥ un error al generar el men√∫. Por favor, int√©ntalo de nuevo m√°s tarde o contacta al soporte.', m);
  }
};

handler.command = ['menu', 'help', 'men√∫'];

export default handler;